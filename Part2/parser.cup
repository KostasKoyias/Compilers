// Package and Import Specifications
import java_cup.runtime.*;

// Usercode Components
parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }

    // define a prefix method returning true if 1st arg is a prefix string of arg2
    static boolean prefix(String pref, String str){
        if(pref.length() > str.length())
            return false;
        int i;
        // if any of the characters of the 1st string(starting from index: 0) 
        // is not identical to the character at the same position of the 2nd, return false
        for(i = 0; i < pref.length(); i++){
            if(pref.charAt(i) != str.charAt(i))
                return false;
        }
        return true;
    }

    // define a suffix method returning true if 1st arg is a suffix string of arg2
    static boolean suffix(String suff, String str){
        if(suff.length() > str.length())
            return false;
        int i;
        // if any of the characters of the 1st string(starting from the last character and going in reverse) 
        // is not identical to the character at the same position of the 2nd, return false
        for(i = suff.length()-1; i >= 0; i--){
            if(suff.charAt(i) != str.charAt(i))
                return false;
        }
        return true;
    }
:}

// define how to connect to the scanner! 
scan with {: return s.next_token(); :};

/* Symbol Lists */

// Terminals (tokens returned by the scanner).
terminal            PLUS, LPAREN, RPAREN, LBRACK, RBRACK, COMMA, KEYWORD, PREFIX, SUFFIX;//, IF, ELSE;
terminal String     IDENTIFIER, STRING_LITERAL;

//  Non terminals
non terminal        prog, def, defs, call, call_list, calls, args, arglist, comma_list, block, exp, exps, concat;//, if_else, cond, oper, opers, e;

// Precedence Declarations
//precedence left PREFIX, SUFFIX;
precedence left PLUS;

/*** The Grammar Rules ***/

// a programm is a mix of definitions and function calls
prog ::= defs:ds calls:cs  {: System.out.println("public class Main{\n\tpublic static void main(String[] args){\n" + cs + "\t}\n" + ds + "\n}"); :}
;
// calls section is either empty or it contains a function call list, new-line seperated
calls ::= call_list:cl             {: RESULT = cl; :}
        | /* empty */              {: RESULT = ""; :} 
;
// a call list is either empty or it has a head and a tail
call_list ::= call_list:cs call:c  {: RESULT = "\t\tSystem.out.println(" + ((String)c).replaceAll("String ","") + ");\n" + cs; :}       
            | call:c               {: RESULT = "\t\tSystem.out.println(" + ((String)c).replaceAll("String ","") + ");\n"; :}
;
// a call is of type identifier arguments e.g foo(args)s
call ::= IDENTIFIER:id args:a      {: RESULT = id + a; :}
;
// arguments are of type (argument_list)
args ::= LPAREN arglist:al RPAREN  {: RESULT = "(" + al + ")"; :}    
;
// the argument list can either be empty or a non-empty comma seperated list of constants
arglist ::= comma_list : c         {: RESULT = c; :}                        
        | /* empty */              {: RESULT = ""; :}                               
;
// a non-empty list of identifiers has either 1 element or a series of comma seperated elements, all identifiers of this language are Strings
comma_list ::= comma_list:cl COMMA IDENTIFIER:id      {: RESULT = cl + ", " + "String " + id; :}
        | comma_list:cl COMMA STRING_LITERAL: sl      {: RESULT = cl + ", " + "String " + "\"" + sl + "\""; :}
        | comma_list:cl COMMA call:c                  {: RESULT = cl + ", " + c; :}
        | IDENTIFIER:id                               {: RESULT = "String " + id; :}
        | STRING_LITERAL: sl                          {: RESULT = "String " + "\"" + sl + "\""; :}
        | call:c                                      {: RESULT = c; :}
;
// a list of definitions is newline-seperated
defs ::= defs:ds def:d             {: RESULT = d + "\n" + ds; :}
        | /*empty*/                {: RESULT = ""; :}
;
// a function definition consists of an identifier and an argument list(like a call) and a code_block
def ::= call:c block:b             {: RESULT = "\tpublic static String " + c + b; :}
;
// a code_block is a brackets surrounded list expressions
block ::= LBRACK exps:es RBRACK    {: RESULT = "{\n" + es + "\t}"; :}
;
// an expression list is either empty or a newline-seperated series of expressions 
exps ::= exps:es exp:e             {: RESULT = e + "\n" + es; :}              
        | /* empty */              {: RESULT = ""; :}
;
// an expression is either a string or a concatenation of them or an if-else type statement
exp ::= concat:c                   {: RESULT = "\t\treturn " + c + ";"; :}                
;
// a concatenation consists of 1 or more '+' seperated identifiers/strings
concat ::= concat:cs PLUS IDENTIFIER:id         {: RESULT = cs + " + " + id; :}
        |  IDENTIFIER: id                       {: RESULT = id; :}
        |  concat:cs PLUS STRING_LITERAL:sl     {: RESULT = cs + " + " + "\"" + sl + "\""; :}
        |  STRING_LITERAL: sl                   {: RESULT = "\"" + sl + "\""; :}
;
/*
exp ::= CONSTANT
    | call
;

exp ::= concat 
    | if_else
;
// a concatenation list is either a constant or a '+' seperated series of constants, where constant is an id or an id in quotes("")
concat ::= CONSTANT
        |  CONSTANT PLUS concat
;
// an if-else type statement is 
if_else ::= IF cond exp ELSE exp
;
// condition is a parentheses surrounded series of operations
cond ::= LPAREN opers RPAREN 
;
// a series of operations
opers ::= exp
        | oper
        | oper opers 
        | CONSTANT
;
// an operation involves two constant and an operator(PLUS, PREFIX or SUFFIX)
oper ::= οper:c1 PLUS οper:c2    {: RESULT = c1 + c2; :}
      |  οper:c1 PREFIX οper:c2  {: RESULT = Parser.prefix(c1, c2); :}
      |  οper:c1 SUFFIX οper:c2  {: RESULT = Parser.suffix(c1, c2); :}
      | LPAREN oper RPAREN
      |  CONSTANT
; */