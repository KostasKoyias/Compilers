// Package and Import Specifications
import java_cup.runtime.*;

// Usercode Components
parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }

    public static String returnExpression(String exp){
        if(exp.contains("if"))
                return exp;
        else 
                return "\t\treturn " + exp;
    }
:}

// define how to connect to the scanner! 
scan with {: return s.next_token(); :};

/* Symbol Lists */

// Terminals (tokens returned by the scanner).
terminal            PLUS, LPAREN, RPAREN, LBRACK, RBRACK, COMMA, PREFIX, SUFFIX, IF, ELSE;
terminal String     IDENTIFIER, STRING_LITERAL;

//  Non terminals
non terminal        prog, def, defs, call, call_list, calls, args, arglist, comma_list, block, exp, exps, str, if_else, cond, conds, op;

// Precedence Declarations
precedence left PREFIX, SUFFIX; // low  - higher in the tree 
precedence left PLUS;           // high - deeper in the tree

/*** The Grammar Rules ***/
start with prog;

// a programm is a mix of definitions and function calls
prog ::= defs:ds calls:cs  {: System.out.println("public class Main{\n\tpublic static void main(String[] args){\n" + cs + "\t}\n" + ds + "\n}"); :}
;
// calls section is either empty or it contains a function call list, new-line seperated
calls ::= call_list:cl             {: RESULT = cl; :}
        | /* empty */              {: RESULT = ""; :} 
;
// a call list is either empty or it has a head and a tail
call_list ::= call_list:cs call:c  {: RESULT = "\t\tSystem.out.println(" + ((String)c).replaceAll("String ","") + ");\n" + cs; :}       
            | call:c               {: RESULT = "\t\tSystem.out.println(" + ((String)c).replaceAll("String ","") + ");\n"; :}
;
// a call is of type identifier arguments e.g foo(args)s
call ::= IDENTIFIER:id args:a      {: RESULT = id + a; :}
;
// arguments are of type (argument_list)
args ::= LPAREN arglist:al RPAREN  {: RESULT = "(" + al + ")"; :}    
;
// the argument list can either be empty or a non-empty comma seperated list of constants
arglist ::= comma_list : c         {: RESULT = c; :}                        
        | /* empty */              {: RESULT = ""; :}                               
;
// a non-empty list of identifiers has either 1 element or a series of comma seperated elements, all identifiers of this language are Strings
comma_list ::= comma_list:cl COMMA IDENTIFIER:id      {: RESULT = cl + ", " + "String " + id; :}
        | comma_list:cl COMMA STRING_LITERAL: sl      {: RESULT = cl + ", " + "String " + "\"" + sl + "\""; :}
        | comma_list:cl COMMA call:c                  {: RESULT = cl + ", " + c; :}
        | IDENTIFIER:id                               {: RESULT = "String " + id; :}
        | STRING_LITERAL: sl                          {: RESULT = "String " + "\"" + sl + "\""; :}
        | call:c                                      {: RESULT = c; :}
;
// a list of definitions is newline-seperated
defs ::= defs:ds def:d          {: RESULT = d + "\n" + ds; :}
        | /*empty*/             {: RESULT = ""; :}
;
// a function definition consists of an identifier and an argument list(like a call) and a code_block
def ::= call:c block:b          {: RESULT = "\tpublic static String " + c + b; :}
;
// a code_block is a brackets surrounded list expressions
block ::= LBRACK exps:es RBRACK {: RESULT = "{\n" + es + "\t}"; :}
;
// an expression list is either empty or a newline-seperated series of expressions 
exps ::= exps:es exp:e          {: RESULT = returnExpression((String)e) + " ;\n" + es; :}              
        | /* empty */           {: RESULT = ""; :}
;
// an expression returns a string by either producing an operation between two expression or returning it right away
exp ::= exp:e1 PLUS exp:e2      {: RESULT = e1 + " + " + e2; :}
    | str:s                     {: RESULT = s; :}
;
// a string can be produced
str ::= IDENTIFIER:id           {: RESULT = id; :}
     |  STRING_LITERAL:sl       {: RESULT = "\"" + sl + "\""; :}
     |  call:c                  {: RESULT = ((String)c).replaceAll("String ",""); :} 
     |  if_else:i               {: RESULT = i; :}
     /*|  LPAREN exp:e RPAREN     {: RESULT = "(" + e + ")"; :}*/
;
// a typical if-then-else expression
if_else ::= IF LPAREN conds:cs RPAREN exp:e1 ELSE exp:e2  {: RESULT = "\t\tif(" + cs + ")\n\t\t" + returnExpression((String)e1) + ";\n\t\telse" + "\n\t\t" + returnExpression((String)e2); :} 
;
// a series of conditions 
conds ::= conds:cs op:o cond:c    {: RESULT = cs + "." + o + "(" + c + ")"; :}
        | cond:c                  {: RESULT = c; :}
;
// a condition is a boolean operation between two expressions(strings)
cond ::= exp:e1 op:o exp:e2       {: RESULT = e2 + "." + o + "(" + e1 + ")"; :}
;
// this language supports two boolean operations:i)prefix and ii)suffix
op ::= PREFIX   {:RESULT = "startsWith"; :}
    |  SUFFIX   {:RESULT = "endsWith"; :}
;